# ADR 009: External Identity Reference Pattern

<!-- Generated by Copilot -->

## Status

Accepted

## Date

2025-11-30

## Context

The ExpenseVault platform uses an Identity Server for centralized authentication and user management. The TransactionService needs to associate transactions with users but must decide how to reference users from an external identity provider.

### Options Considered

1. **Local User Entity with FK Constraint**
   - Create a local `User` table with foreign key relationships
   - Sync user data from Identity Server
   - Pros: Enables JOIN queries, enforces referential integrity
   - Cons: Data duplication, sync complexity, tight coupling

2. **External Reference (UserId as Guid)**
   - Store only `UserId` as a Guid without FK constraint
   - Fetch user details from Identity Server when needed
   - Pros: Loose coupling, single source of truth, simpler data model
   - Cons: Cannot JOIN, requires API calls for user info

3. **Event-Driven Denormalized Read Model**
   - Subscribe to Identity Server events
   - Maintain a read-only cache of user data
   - Pros: Fast reads, no runtime API calls
   - Cons: Eventual consistency, additional infrastructure

## Decision

We chose **Option 2: External Reference Pattern** - storing only `UserId` as a Guid without foreign key constraint or navigation property.

### Implementation

```csharp
// Domain Entity - No User navigation property
public sealed class Transaction : AuditableEntityBase<Guid>
{
    /// <summary>
    /// External reference to Identity Server user
    /// </summary>
    public Guid UserId { get; private set; }
    
    // No User navigation property - it's external!
}

// EF Configuration - No FK constraint
public void Configure(EntityTypeBuilder<Transaction> builder)
{
    builder.Property(x => x.UserId)
        .IsRequired();

    // Note: UserId is an external reference to Identity Server
    // No FK constraint - data integrity managed by Identity Server
    
    // Index for queries
    builder.HasIndex(x => new { x.UserId, x.Date })
        .HasDatabaseName("IX_Transactions_UserId_Date");
}
```

### User Information Retrieval

When user information is needed (e.g., for display):

```csharp
// Via gRPC or HTTP client to Identity Server
public interface IIdentityServiceClient
{
    Task<UserInfo?> GetUserAsync(Guid userId, CancellationToken ct);
    Task<IReadOnlyList<UserInfo>> GetUsersAsync(IEnumerable<Guid> userIds, CancellationToken ct);
}

// With caching
public class CachedIdentityServiceClient : IIdentityServiceClient
{
    private readonly HybridCache _cache;
    private readonly IIdentityServiceClient _inner;

    public async Task<UserInfo?> GetUserAsync(Guid userId, CancellationToken ct)
    {
        return await _cache.GetOrCreateAsync(
            $"user:{userId}",
            async token => await _inner.GetUserAsync(userId, token),
            new HybridCacheEntryOptions { Expiration = TimeSpan.FromMinutes(15) },
            cancellationToken: ct);
    }
}
```

## Consequences

### Positive

- **Service Independence**: TransactionService has no dependency on User schema
- **Single Source of Truth**: User data lives only in Identity Server
- **Simplified Data Model**: No User table, no sync logic
- **Bounded Context Separation**: Clean microservice boundaries
- **Flexibility**: Can switch Identity providers without database migration
- **No Orphan Risk**: Deleted users don't cause FK violations

### Negative

- **No JOIN Queries**: Cannot join with User table for reports
- **API Calls Required**: Must call Identity Server for user details
- **Eventual Consistency**: User deletions not immediately reflected
- **Index-Only Filtering**: Can only filter by UserId, not user properties

### Mitigations

| Concern | Mitigation |
|---------|------------|
| Performance | Use HybridCache with Redis L2 for user info |
| Batch Queries | Batch user lookups with `GetUsersAsync` |
| Reporting | Use dedicated reporting service with denormalized data |
| User Deletion | Handle via async events or periodic cleanup |

## Related Decisions

- [ADR 001: Clean Architecture](./001-clean-architecture.md)
- [ADR 002: CQRS Pattern](./002-cqrs-pattern.md)
- [ADR 008: Soft Delete Pattern](./008-soft-delete-pattern.md)

## References

- [Building Microservices - Sam Newman](https://samnewman.io/books/building_microservices/)
- [Microsoft: Data considerations in microservices](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/data-sovereignty-per-microservice)
- [DDD Bounded Contexts](https://martinfowler.com/bliki/BoundedContext.html)
