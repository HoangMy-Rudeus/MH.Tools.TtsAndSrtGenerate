# ADR 003: PostgreSQL & Entity Framework Core

<!-- Generated by Copilot -->

## Status

**Accepted**

## Context

We need to choose a database and ORM for the TransactionService that:

- Handles high volume of financial transactions
- Supports complex queries and reporting
- Provides strong ACID guarantees
- Supports future partitioning needs
- Integrates well with .NET ecosystem

## Decision

We will use **PostgreSQL 16** as our database with **Entity Framework Core** as the ORM.

### Database: PostgreSQL

Chosen for:

- **ACID compliance**: Critical for financial data
- **Native partitioning**: Built-in support for table partitioning
- **JSON support**: JSONB for flexible data (tags, metadata)
- **Performance**: Excellent for read-heavy and write-heavy workloads
- **Open source**: No licensing costs
- **pg_partman**: Extension for automated partition management

### ORM: Entity Framework Core

Chosen for:

- **First-class .NET support**: Microsoft-backed, excellent tooling
- **Migrations**: Code-first database versioning
- **LINQ**: Type-safe queries
- **Change tracking**: Automatic dirty checking
- **PostgreSQL provider**: Npgsql.EntityFrameworkCore.PostgreSQL

### No Repository Pattern

We chose **not** to use the Repository pattern:

```csharp
// Instead of:
public interface ITransactionRepository
{
    Task<Transaction?> GetByIdAsync(Guid id);
}

// We use:
public class Handler
{
    private readonly ApplicationDbContext _context;
    
    public async Task<Transaction?> Handle(...)
    {
        return await _context.Transactions
            .FirstOrDefaultAsync(t => t.Id == id);
    }
}
```

**Rationale**: EF Core DbContext IS already a Unit of Work + Repository. Adding another layer provides minimal value and increases complexity.

### Configuration

```csharp
public class TransactionConfiguration : IEntityTypeConfiguration<Transaction>
{
    public void Configure(EntityTypeBuilder<Transaction> builder)
    {
        builder.ToTable("Transactions");
        builder.HasKey(t => t.Id);
        
        // Value object mapping
        builder.OwnsOne(t => t.Amount);
        builder.OwnsOne(t => t.Location);
        
        // Indexes
        builder.HasIndex(t => t.WalletId);
        builder.HasIndex(t => t.TransactionDate);
    }
}
```

## Consequences

### Positive

- **Reliability**: PostgreSQL's ACID guarantees protect financial data
- **Flexibility**: Native JSON support for evolving schema
- **Scalability**: Partitioning support for large datasets
- **Simplicity**: No repository abstraction layer
- **Ecosystem**: Rich tooling (pgAdmin, pg_partman, etc.)

### Negative

- **PostgreSQL lock-in**: Harder to switch databases (mitigated by EF Core abstraction)
- **Learning curve**: PostgreSQL-specific features require knowledge
- **No in-memory testing**: Need Testcontainers for integration tests

### Mitigations

- EF Core abstracts most PostgreSQL specifics
- Testcontainers for realistic integration tests
- Documentation of PostgreSQL-specific features used

## Alternatives Considered

### SQL Server

**Rejected because**: Higher licensing costs, PostgreSQL partitioning is more mature.

### MongoDB

**Rejected because**: ACID transactions are complex, relational data fits better in RDBMS.

### Dapper (micro-ORM)

**Rejected because**: Loses change tracking, migrations, and LINQ benefits. Could use for read-optimized queries later.

## References

- [PostgreSQL Partitioning](https://www.postgresql.org/docs/current/ddl-partitioning.html)
- [EF Core with PostgreSQL](https://www.npgsql.org/efcore/)
- [pg_partman](https://github.com/pgpartman/pg_partman)

---

**Navigation**: [Previous: CQRS with MediatR](002-mediatr-cqrs.md) | [Next: Hybrid Caching](004-hybrid-caching.md)
