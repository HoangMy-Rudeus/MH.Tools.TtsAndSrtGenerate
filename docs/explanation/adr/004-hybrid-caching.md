# ADR 004: Hybrid Caching Strategy

<!-- Generated by Copilot -->

## Status

**Accepted**

## Context

We need a caching strategy for the TransactionService that:

- Reduces database load for frequently accessed data
- Provides fast response times
- Works in a distributed environment
- Is resilient to cache failures

## Decision

We will use **.NET HybridCache** with a two-level caching strategy:

### Architecture

```
Request
    │
    ▼
┌─────────────────┐
│   HybridCache   │
└────────┬────────┘
         │
    ┌────┴────┐
    │         │
    ▼         ▼
┌───────┐ ┌───────┐
│  L1   │ │  L2   │
│Memory │ │ Redis │
└───────┘ └───────┘
```

### L1 Cache (In-Memory)

- **Location**: Same process as application
- **Speed**: Nanoseconds access
- **Size**: Limited (configurable)
- **Scope**: Per-instance (not shared)

### L2 Cache (Redis)

- **Location**: External Redis server
- **Speed**: Milliseconds access
- **Size**: Larger capacity
- **Scope**: Distributed (shared across instances)

### Implementation

```csharp
// Configuration
services.AddHybridCache(options =>
{
    options.DefaultEntryOptions = new HybridCacheEntryOptions
    {
        Expiration = TimeSpan.FromMinutes(5),
        LocalCacheExpiration = TimeSpan.FromMinutes(1)
    };
});

services.AddStackExchangeRedisCache(options =>
{
    options.Configuration = "localhost:6379";
});

// Usage
public class GetTransactionByIdQueryHandler
{
    private readonly HybridCache _cache;
    
    public async Task<TransactionDto?> Handle(GetTransactionByIdQuery request, ...)
    {
        return await _cache.GetOrCreateAsync(
            $"transaction:{request.Id}",
            async token => await LoadFromDatabase(request.Id, token),
            cancellationToken: cancellationToken);
    }
}
```

### Cache Key Convention

```
Pattern: {entity}:{identifier}

Examples:
- transaction:{guid}
- transactions:wallet:{walletId}:page:{pageNumber}
```

### Cache Invalidation

**Strategy**: Cache-aside with TTL-based expiration

```csharp
// After create/update/delete
await _cache.RemoveAsync($"transaction:{id}");
```

## Consequences

### Positive

- **Performance**: Sub-millisecond reads for cached data
- **Resilience**: L1 continues if Redis is unavailable
- **Scalability**: Redis handles distributed caching
- **Simplicity**: HybridCache abstracts complexity

### Negative

- **Stale data**: TTL means data can be slightly stale
- **Memory usage**: L1 cache uses application memory
- **Complexity**: Cache invalidation requires careful handling
- **Redis dependency**: Additional infrastructure to manage

### Mitigations

- Short TTL for frequently changing data
- Explicit invalidation on writes
- Circuit breaker for Redis failures
- Monitoring of cache hit rates

## Alternatives Considered

### Redis Only

**Rejected because**: Every read requires network call, L1 provides significant speedup for hot data.

### In-Memory Only

**Rejected because**: Not suitable for distributed deployment, each instance has different cache state.

### IMemoryCache + IDistributedCache manually

**Rejected because**: HybridCache handles the coordination automatically and is the modern .NET approach.

## Configuration

```json
{
  "Caching": {
    "DefaultExpirationMinutes": 5,
    "LocalExpirationMinutes": 1,
    "KeyPrefix": "transaction:",
    "Redis": {
      "ConnectionString": "localhost:6379",
      "InstanceName": "transactionservice:"
    }
  }
}
```

## References

- [.NET HybridCache](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/hybrid)
- [Redis Caching Best Practices](https://redis.io/docs/manual/patterns/)

---

**Navigation**: [Previous: PostgreSQL & EF Core](003-postgresql-ef-core.md) | [Next: Error Handling](005-centralized-error-handling.md)
