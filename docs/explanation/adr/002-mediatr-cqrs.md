# ADR 002: CQRS with MediatR

<!-- Generated by Copilot -->

## Status

**Accepted**

## Context

We need a pattern for handling application logic that:

- Separates read and write operations
- Provides a clear structure for use cases
- Supports cross-cutting concerns (validation, logging, caching)
- Makes code testable and maintainable

## Decision

We will use **CQRS (Command Query Responsibility Segregation)** implemented with **MediatR**.

### Pattern Structure

**Commands** (Write Operations):

```csharp
// Command definition
public record CreateTransactionCommand(
    Guid WalletId,
    Guid CategoryId,
    decimal Amount,
    string Currency,
    TransactionType Type,
    string Description,
    DateTimeOffset TransactionDate
) : IRequest<Guid>;

// Command handler
public class CreateTransactionCommandHandler 
    : IRequestHandler<CreateTransactionCommand, Guid>
{
    public async Task<Guid> Handle(
        CreateTransactionCommand request, 
        CancellationToken cancellationToken)
    {
        // Implementation
    }
}
```

**Queries** (Read Operations):

```csharp
// Query definition
public record GetTransactionByIdQuery(Guid Id) 
    : IRequest<TransactionDto?>;

// Query handler
public class GetTransactionByIdQueryHandler 
    : IRequestHandler<GetTransactionByIdQuery, TransactionDto?>
{
    public async Task<TransactionDto?> Handle(
        GetTransactionByIdQuery request, 
        CancellationToken cancellationToken)
    {
        // Implementation
    }
}
```

### MediatR Pipeline

```
Request → Validation → Logging → Caching → Handler → Response
```

Behaviors:
- `ValidationBehavior` - FluentValidation integration
- `LoggingBehavior` - Request/response logging
- `CachingBehavior` - Query caching (future)

## Consequences

### Positive

- **Separation of concerns**: Read and write paths are clearly separated
- **Single Responsibility**: Each handler does one thing
- **Testability**: Handlers can be tested in isolation
- **Pipeline**: Cross-cutting concerns handled consistently
- **Scalability**: Read and write can be scaled independently (future)

### Negative

- **Indirection**: Request → Handler adds a layer
- **Boilerplate**: Each use case needs request + handler
- **Learning curve**: Developers need to understand the pattern

### Mitigations

- Code generators/templates for commands and queries
- Clear naming conventions
- Documentation of common patterns

## Alternatives Considered

### Direct service methods

```csharp
public interface ITransactionService
{
    Task<Guid> CreateAsync(CreateTransactionDto dto);
    Task<TransactionDto?> GetByIdAsync(Guid id);
}
```

**Rejected because**: Harder to add cross-cutting concerns, less explicit about read/write separation.

### Full Event Sourcing

**Rejected because**: Over-engineering for current requirements. Can be added later if audit trail becomes critical.

## References

- [MediatR Documentation](https://github.com/jbogard/MediatR)
- [CQRS Pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs)

---

**Navigation**: [Previous: Clean Architecture](001-clean-architecture.md) | [Next: PostgreSQL & EF Core](003-postgresql-ef-core.md)
