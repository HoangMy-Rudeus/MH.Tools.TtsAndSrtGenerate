# ADR 008: Soft Delete Pattern

<!-- Generated by Copilot -->

## Status

**Accepted**

## Context

Financial data requires special handling for deletion:

- **Audit requirements**: Need to maintain transaction history
- **Data recovery**: Users may accidentally delete data
- **Referential integrity**: Other services may reference transactions
- **Compliance**: Tax and regulatory requirements mandate data retention

We need a deletion strategy that balances:
- User experience (data appears deleted)
- Compliance (data is retained)
- Performance (queries exclude deleted data)

## Decision

We will implement **soft delete** using `IsDeleted` and `DeletedAt` columns, inherited from a base class.

### Implementation

**Base Entity**:

```csharp
public abstract class AuditableEntityBase
{
    public Guid Id { get; protected set; }
    public DateTimeOffset CreatedAt { get; protected set; }
    public DateTimeOffset? UpdatedAt { get; protected set; }
    public bool IsDeleted { get; protected set; }
    public DateTimeOffset? DeletedAt { get; protected set; }
    
    public void MarkAsDeleted()
    {
        IsDeleted = true;
        DeletedAt = DateTimeOffset.UtcNow;
    }
    
    public void Restore()
    {
        IsDeleted = false;
        DeletedAt = null;
    }
}
```

**Transaction Entity**:

```csharp
public class Transaction : AuditableEntityBase
{
    // All transactions inherit soft delete capability
}
```

**Global Query Filter**:

```csharp
public class TransactionConfiguration : IEntityTypeConfiguration<Transaction>
{
    public void Configure(EntityTypeBuilder<Transaction> builder)
    {
        // Automatically exclude deleted records from all queries
        builder.HasQueryFilter(t => !t.IsDeleted);
        
        // Index for performance
        builder.HasIndex(t => t.IsDeleted)
            .HasFilter("\"IsDeleted\" = false");
    }
}
```

### Query Behavior

**Normal queries** (automatic filtering):
```csharp
// Returns only non-deleted transactions
var transactions = await dbContext.Transactions.ToListAsync();
```

**Include deleted** (explicit):
```csharp
// Returns all transactions including deleted
var allTransactions = await dbContext.Transactions
    .IgnoreQueryFilters()
    .ToListAsync();
```

**Query deleted only**:
```csharp
// Returns only deleted transactions
var deleted = await dbContext.Transactions
    .IgnoreQueryFilters()
    .Where(t => t.IsDeleted)
    .ToListAsync();
```

### Delete Operation

```csharp
public async Task DeleteTransactionAsync(Guid id)
{
    var transaction = await dbContext.Transactions.FindAsync(id);
    if (transaction == null) return;
    
    transaction.MarkAsDeleted();
    await dbContext.SaveChangesAsync();
}
```

## Consequences

### Positive

- **Audit Trail**: Complete history is maintained
- **Recovery**: Easy to restore accidentally deleted data
- **Compliance**: Meets data retention requirements
- **Transparent**: Global filters hide complexity from developers

### Negative

- **Storage**: Deleted data still uses space
- **Performance**: Slightly larger indexes
- **Complexity**: Need to remember `IgnoreQueryFilters()` for audits
- **Unique constraints**: Must account for soft-deleted records

### Mitigations

- Periodic archival of old soft-deleted records
- Compound indexes include `IsDeleted`
- Documentation of when to use `IgnoreQueryFilters()`
- Unique indexes use partial filter: `WHERE "IsDeleted" = false`

## Alternatives Considered

### Hard Delete

```csharp
dbContext.Transactions.Remove(transaction);
```

**Rejected because**: No audit trail, no recovery, compliance issues.

### Separate Archive Table

```sql
INSERT INTO transactions_archive SELECT * FROM transactions WHERE id = @id;
DELETE FROM transactions WHERE id = @id;
```

**Rejected because**: More complex, requires maintaining two tables, cross-table queries difficult.

### Event Sourcing with Tombstones

```csharp
await eventStore.Append(new TransactionDeleted(id));
```

**Rejected because**: Over-engineering for current requirements. May consider for future audit features.

## Related Decisions

- Partitioning ([ADR 007](007-database-partitioning.md)): Soft-deleted records stay in their partition
- Archival: After retention period, soft-deleted records can be hard-deleted or moved to archive storage

---

**Navigation**: [Previous: Database Partitioning](007-database-partitioning.md) | [ADR Index](../README.md)
