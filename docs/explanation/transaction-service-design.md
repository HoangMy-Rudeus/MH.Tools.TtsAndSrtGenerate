# TransactionService Design

<!-- Generated by Copilot -->

> Core design philosophy and principles for the TransactionService

## Overview

The TransactionService is designed as a domain-centric microservice following Clean Architecture principles. It manages financial transactions within the ExpenseVault ecosystem.

## Design Principles

### 1. Domain-Driven Design

The service is built around the Transaction domain model:

```
Transaction (Aggregate Root)
├── Money (Value Object)
├── Location (Value Object)
├── TransactionAttachment (Entity)
└── RecurringTransaction (Entity)
```

**Key Concepts:**

- **Aggregate Root**: Transaction is the main aggregate root
- **Value Objects**: Immutable objects like Money and Location
- **Entities**: Objects with identity like TransactionAttachment

### 2. Clean Architecture

```
┌─────────────────────────────────────────┐
│              API Layer                   │
│         (FastEndpoints)                  │
├─────────────────────────────────────────┤
│          Application Layer               │
│      (Commands, Queries, DTOs)           │
├─────────────────────────────────────────┤
│         Infrastructure Layer             │
│     (EF Core, Configurations)            │
├─────────────────────────────────────────┤
│            Domain Layer                  │
│    (Entities, Value Objects, Enums)      │
└─────────────────────────────────────────┘
```

**Dependency Rule**: Dependencies only point inward. Domain has no external dependencies.

### 3. CQRS Pattern

Separate read and write operations:

- **Commands**: Modify state (CreateTransactionCommand)
- **Queries**: Read state (GetTransactionByIdQuery)

**Benefits:**

- Optimized read/write paths
- Clear separation of concerns
- Easier to scale independently

### 4. No Repository Pattern

Direct DbContext usage through extension methods:

```csharp
// Instead of repository
var transaction = await dbContext.Transactions
    .FirstOrDefaultAsync(t => t.Id == id);
```

**Rationale:**

- EF Core IS the repository
- Reduces abstraction layers
- Simpler codebase

## Domain Model

### Transaction Entity

The core entity representing a financial transaction:

```csharp
public class Transaction : AuditableEntityBase
{
    public Guid WalletId { get; private set; }
    public Guid CategoryId { get; private set; }
    public Money Amount { get; private set; }
    public TransactionType Type { get; private set; }
    public string Description { get; private set; }
    public DateTimeOffset TransactionDate { get; private set; }
    public string? Notes { get; private set; }
    public Location? Location { get; private set; }
    public IReadOnlyCollection<string> Tags { get; }
    public IReadOnlyCollection<TransactionAttachment> Attachments { get; }
}
```

### Value Objects

**Money**: Encapsulates amount with currency

```csharp
public record Money(decimal Amount, string Currency);
```

**Location**: Geographic coordinates with address

```csharp
public record Location(double Latitude, double Longitude, string? Address);
```

### Enumerations

**TransactionType**: Income, Expense, Transfer

**RecurrenceFrequency**: Daily, Weekly, Monthly, etc.

**AttachmentType**: Receipt, Invoice, Document, etc.

## Data Flow

### Create Transaction Flow

```
1. HTTP POST /api/transactions
      ↓
2. CreateTransactionEndpoint
      ↓
3. CreateTransactionCommand (MediatR)
      ↓
4. CreateTransactionCommandHandler
      ↓
5. Transaction.Create() (Domain factory)
      ↓
6. DbContext.SaveChangesAsync()
      ↓
7. Return Transaction ID
```

### Query Transaction Flow

```
1. HTTP GET /api/transactions/{id}
      ↓
2. GetTransactionByIdEndpoint
      ↓
3. GetTransactionByIdQuery (MediatR)
      ↓
4. GetTransactionByIdQueryHandler
      ↓
5. DbContext.Transactions.FirstOrDefaultAsync()
      ↓
6. Map to TransactionDto
      ↓
7. Return DTO or 404
```

## Caching Strategy

Using HybridCache with Redis L2:

```csharp
// Cache key pattern
"transaction:{id}"

// Cache configuration
- L1: In-memory (fast, limited size)
- L2: Redis (distributed, larger capacity)
- Default TTL: 5 minutes
```

## Future Considerations

### Database Partitioning

Quarterly RANGE partitioning by TransactionDate:

```sql
CREATE TABLE transactions (
    id UUID,
    transaction_date TIMESTAMPTZ,
    ...
) PARTITION BY RANGE (transaction_date);
```

### Event Sourcing

Consider for audit trail:

- TransactionCreated
- TransactionModified
- TransactionDeleted

### Multi-tenancy

Wallet-based isolation with RLS (Row Level Security).

---

**Navigation**: [Explanation Home](README.md) | [Documentation Map](../DOCUMENTATION_MAP.md)
